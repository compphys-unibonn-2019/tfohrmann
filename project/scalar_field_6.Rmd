---
title: "scalar_field"
author: "Till Fohrmann"
date: "3/6/2020"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

##Function definitions
```{r}
roll <- function(x, d=1, n=1){
  #Utility function to roll a 4d-array in one of the dimensions d by n places.
  #This function is used to avoid loops when calculating the product of neighbouring array elements.
  n_t <- dim(x)[1]
  n_s <- dim(x)[2]
  rolled_arr <- array(dim=dim(x))
  
  if(n < 0){
    n <- abs(n)
    if(d==1){
      n <- (n-1)%% n_t + 1
      if(n==n_t) return(x)
      rolled_arr[seq(1,n_t-n),,,] <- x[seq(n+1,n_t),,,]
      rolled_arr[seq(n_t-n+1,n_t),,,] <- x[seq(1,n),,,]
    }
    else if(d==2){
      n <- (n-1)%% n_s + 1
      if(n==n_s) return(x)
      rolled_arr[,seq(1,n_s-n),,] <- x[,seq(n+1,n_s),,]
      rolled_arr[,seq(n_s-n+1,n_s),,] <- x[,seq(1,n),,]
    }
    else if(d==3){
      n <- (n-1)%% n_s + 1
      if(n==n_s) return(x)
      rolled_arr[,,seq(1,n_s-n),] <- x[,,seq(n+1,n_s),]
      rolled_arr[,,seq(n_s-n+1,n_s),] <- x[,,seq(1,n),]
    }
    else{
      n <- (n-1)%% n_s + 1
      if(n==n_s) return(x)
      rolled_arr[,,,seq(1,n_s-n)] <- x[,,,seq(n+1,n_s)]
      rolled_arr[,,,seq(n_s-n+1,n_s)] <- x[,,,seq(1,n)]
    }
  }
  else{
    if(d==1){
      n <- (n-1)%% n_t + 1
      if(n==n_t) return(x)
      rolled_arr[seq(1+n,n_t),,,] <- x[seq(1,n_t-n),,,]
      rolled_arr[seq(1,n),,,] <- x[seq(n_t-n+1,n_t),,,]
    }
    else if(d==2){
      n <- (n-1)%% n_s + 1
      if(n==n_s) return(x)
      rolled_arr[,seq(1+n,n_s),,] <- x[,seq(1,n_s-n),,]
      rolled_arr[,seq(1,n),,] <- x[,seq(n_s-n+1,n_s),,]
    }
    else if(d==4){
      n <- (n-1)%% n_s + 1
      if(n==n_s) return(x)
      rolled_arr[,,seq(1+n,n_s),] <- x[,,seq(1,n_s-n),]
      rolled_arr[,,seq(1,n),] <- x[,,seq(n_s-n+1,n_s),]
    }
    else{
      n <- (n-1)%% n_s + 1
      if(n==n_s) return(x)
      rolled_arr[,,,seq(1+n,n_s)] <- x[,,,seq(1,n_s-n)]
      rolled_arr[,,,seq(1,n)] <- x[,,,seq(n_s-n+1,n_s)]
    }
  }
  
  return(rolled_arr)
}


lat_action <- function(lattice, mass, field){
  #Used to calculate the action of a given lattice.
  
  #Derivatives
  #Time
  action <- sum((lattice - roll(lattice, d=1, n=-1))^2 + (lattice - roll(lattice, d=1, n=1))^2)/2.0
  #x-Direction
  action <- action + sum((lattice - roll(lattice, d=2, n=-1))^2 + (lattice - roll(lattice, d=2, n=1))^2)/2.0
  #y-Direction
  action <- action + sum((lattice - roll(lattice, d=3, n=-1))^2 + (lattice - roll(lattice, d=3, n=1))^2)/2.0
  #z-Direction
  action <- action + sum((lattice - roll(lattice, d=4, n=-1))^2 + (lattice - roll(lattice, d=4, n=1))^2)/2.0
  
  #Pure field terms
  action <- action - mass^2/2.0 * sum(lattice^2) - field/24.0 * sum(lattice^4)
  
  return(action)
}


sp_contribution <- function(lattice, x, mass, field, zeta){
  #Calculates the part of the action associated with a single point x on the lattice.
  
  point <- lattice[x[1],x[2],x[3],x[4]]
  tmp <- 0
  
  #Derivatives
  #Time
  tmp <- tmp - 2.0*mass*zeta * point * lattice[(x[1]-2)%%dim(lattice)[1]+1,x[2],x[3],x[4]] #before
  tmp <- tmp - 2.0*mass*zeta * point * lattice[x[1]%%dim(lattice)[1]+1,x[2],x[3],x[4]] #after
  #x-Direction
  tmp <- tmp - 2.0*mass/zeta * point * lattice[x[1],(x[2]-2)%%dim(lattice)[2]+1,x[3],x[4]]
  tmp <- tmp - 2.0*mass/zeta * point * lattice[x[1],x[2]%%dim(lattice)[2]+1,x[3],x[4]]
  #y-Direction
  tmp <- tmp - 2.0*mass/zeta * point * lattice[x[1],x[2],(x[3]-2)%%dim(lattice)[3]+1,x[4]]
  tmp <- tmp - 2.0*mass/zeta * point * lattice[x[1],x[2],x[3]%%dim(lattice)[3]+1,x[4]]
  #z-Direction
  tmp <- tmp - 2.0*mass/zeta * point * lattice[x[1],x[2],x[3],(x[4]-2)%%dim(lattice)[4]+1]
  tmp <- tmp - 2.0*mass/zeta * point * lattice[x[1],x[2],x[3],x[4]%%dim(lattice)[4]+1]
  
  #Pure field terms
  tmp <- tmp + (1-2*field) * point^2 + field * point^4
  
  return(tmp)
}


field_sweep <- function(lattice, mass, field, zeta){
  #Sequentially updates the lattice.
  
  proposal <- lattice
  n_t <- dim(lattice)[1]
  n_s <- dim(lattice)[2]
  AR <- 0 #acceptance ratio
  w <- 1 #width of uniform distr.
  
  
  for(t in seq(1,n_t)){
    for(x in seq(1,n_s)){
      for(y in seq(1,n_s)){
        for(z in seq(1,n_s)){
          proposal[t,x,y,z] <- proposal[t,x,y,z] + runif(n=1, min=-w, max=w)
        
          S_before <- sp_contribution(lattice, c(t,x,y,z), mass, field, zeta)
          #S_before <- lat_action(lattice, mass, field, zeta)
          S_after <- sp_contribution(proposal, c(t,x,y,z), mass, field, zeta)
          #S_after <- lat_action(proposal, mass, field, zeta)
          del_S <- S_after - S_before
        
          #Accept-Reject-Step
          if(runif(1) < exp(-del_S)){
            lattice[t,x,y,z] <- proposal[t,x,y,z]
            AR <- AR + 1
          }
          else
            proposal[t,x,y,z] <- lattice[t,x,y,z]
        }
      }
    }
  }
  return(list("lattice"=lattice, "AR"=AR/(n_t*n_s^3)))
}


two_point <- function(lattice){
  #Calculates the (symmetrized) two point function/correlator for a given lattice (using the roll function).
  n_t <- dim(lattice)[1]
  n_s <- dim(lattice)[2]
  corr <- rep(0, n_t/2+1)

  for(dt in seq(0,n_t/2)){
    rolled <- roll(lattice, d=1, n=-dt)
    corr[dt+1] <- sum(lattice * rolled)
  }
  # for(dt in seq(0,n_t)){
  #   for(t0 in seq(1,n_t)){
  #     for(x in seq(1,n_s)){
  #       for(y in seq(1,n_s)){
  #         for(z in seq(1,n_s)){
  #           corr[dt+1] <- corr[dt+1] + lattice[t0,x,y,z] * lattice[(t0+dt-1)%%n_t+1,x,y,z]
  #         }
  #       }
  #     }
  #   }
  # }
  
  return(corr/(n_t*n_s^3))

  #Symmetrize correlator:
  corr_sym <- (head(corr, n_t/4+1)+tail(corr, n_t/4+1))/2.

  return(corr_sym/(n_t*n_s^3))
}


eff_mass <- function(corr){
  #Calculates the effective mass for all time steps.
  
  N <- length(corr)
  return(log(corr[1:N-1]/tail(corr,N-1)))
}
```

##Set up a space-time lattice
```{r}
mass <- 1
field <- 0
zeta <- 1

n_s <- 32 #points per space dimension
n_t <- 32 #points per time dimension
```

##Calculate the average correlator and the effective mass (using the MH-sweeps done in C)
```{r}
corr <- array(data=NA, dim=c(1000,n_t/2+1))
for(i in seq(1,1000,1)){
  tmp_vec <- scan(file=paste(c("./m1f0/sweep_", i, ".txt"), collapse = ""), sep=",", quiet=T)
  lattice <- array(tmp_vec[-length(tmp_vec)], dim=c(32,32,32,32))
  corr[i,] <- two_point(lattice)
}
mean_corr <- apply(X=corr, MARGIN=2, FUN=mean)
m_eff <- eff_mass(mean_corr)
```

```{r}
# i <- 100
# tmp_vec <- scan(file=paste(c("./m1f0/sweep_", i, ".txt"), collapse = ""), sep=",", quiet=T)
# lattice <- array(tmp_vec[-length(tmp_vec)], dim=c(32,32,32,32))
# corr <- two_point(lattice)
#print(corr)
plot(seq(0,length(mean_corr)-1),mean_corr)
#plot(seq(1,length(corr)-1),eff_mass(corr))
#plot(seq(0,15),corr[1:16])
plot(seq(1,length(m_eff)),m_eff,pch=4)
```

##Visualisation of simulation steps
```{r}
for(i in seq(1,40,1)){
  tmp_vec <- scan(file=paste(c("./m1f0/sweep_", i, ".txt"), collapse = ""), sep=",", quiet=T)
  tmp_arr <- array(tmp_vec[-length(tmp_vec)], dim=c(32,16,16,16))
  heatmap(x=tmp_arr[1,1,,], Rowv=NA, Colv=NA, scale="none")
}
```


# Metropolis-Hastings in R
##Perform N sweeps of the lattice
```{r}
#lattice <- array(data=runif(n=n_t*n_s^3,min=-1,max=1),dim=c(n_t,n_s,n_s,n_s))
#lattice <- lattice/sum(lattice)
#saveRDS(lattice, file="./size_32/rndm_init.rds")
#heatmap(x=lattice[1,,,], Rowv=NA, Colv=NA, scale="none")
lattice <- readRDS("./m1f0z1/step_5.rds")

AR <- 0 #acceptance ratio
n_sweeps <- 0 #number of sweeps

#Thermalise
for(i in seq(5,100)){
  sweep <- field_sweep(lattice, mass, field, zeta)
  lattice <- sweep$lattice
  AR <- AR + sweep$AR/n_sweeps
  print(c("Step", i, " thermalisation"))
}
saveRDS(lattice, file="./m1f0z1/thermal.rds")

for(i in seq(1,n_sweeps)){
  sweep <- field_sweep(lattice, mass, field, zeta)
  lattice <- sweep$lattice
  AR <- AR + sweep$AR/n_sweeps
  saveRDS(lattice, file=paste(c("./m1f0z1/step_", i, ".rds"), collapse = ""))
  print(c("Step", i))
}

#print(lattice[,,])
#heatmap(x=lattice[1,,,], Rowv=NA, Colv=NA, scale="none")
```

##Visualisation of simulation steps
```{r}
for(i in seq(1,5,1)){
  heatmap(x=readRDS(paste(c("./m1f0z1/step_", i, ".rds"), collapse = ""))[1,1,,], Rowv=NA, Colv=NA, scale="none")
}
```

##Calculate the average correlator and the effective mass (using the MH-sweeps done in R)
```{r}
for(i in seq(1,5)){
  lattice <- readRDS(paste(c("./m1f0z1/step_", i, ".rds"), collapse = ""))
  corr <- array(NA, dim=c(n_t,5))
  for(i in seq(1,n_t)){
    corr[,i] <- two_point(lattice=lattice, mass=mass, field=field, zeta=zeta, d_t=i)
  }
  corr_avg <- apply(X=corr, MARGIN=1, FUN=mean)
}
print(eff_mass(corr_avg))
```





## Change in action over MH-Updates (for C generated files)
```{r}
lattice <- array(data=runif(n=n_t*n_s^3,min=-1,max=1),dim=c(n_t,n_s,n_s,n_s))
lat_action(lattice,mass,field,zeta)
```

```{r}
trend <- rep(0,4700)
for(i in seq(1,4700,1)){
  tmp_vec <- scan(file=paste(c("./m1f0/sweep_", i, ".txt"), collapse = ""), sep=",", quiet=T)
  tmp_arr <- array(tmp_vec[-length(tmp_vec)], dim=c(32,16,16,16))
  trend[i] <- lat_action(tmp_arr,mass,field)
}
```

```{r}
#print(trend)
plot(seq(1:4700),trend)
```

```{r}
correlator <- simplify2array(read.csv("./correlator.txt", header=F))
correlator <- correlator/(n_t*n_s^2)
mean_corr <- apply(X=correlator, MARGIN=2, FUN=mean)
m_eff <- eff_mass(mean_corr)
```

```{r}
dim(correlator)
```

```{r}
#plot(seq(1:length(mean_corr)-1), mean_corr)
#plot(seq(1:length(m_eff)-1), m_eff)
x <- seq(3:length(corr[1,])-1)
plot(x,corr[1,3:17])
abline(h=0)
for(i in seq(2:1000)){
  points(x,corr[i,3:17])
}
```
```{r}
autocor <- cor(t(correlator))
plot(seq(0,dim(autocor)[1]-1),autocor[1,], type="l")
#dim(autocor)
```

