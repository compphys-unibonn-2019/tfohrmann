---
title: "scalar_field"
author: "Till Fohrmann"
date: "3/6/2020"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


##Function definitions
```{r}
sp_contribution <- function(lattice, x, mass, field, zeta){
  #Calculates the parts of the action that change if the field value at on point changes.
  
  point <- lattice[x[1],x[2],x[3]]
  tmp <- 0
  
  #Interacting
  #Time
  tmp <- tmp - 2.0*mass*zeta * point * lattice[(x[1]-2)%%dim(lattice)[1]+1,x[2],x[3]] #before
  tmp <- tmp - 2.0*mass*zeta * point * lattice[x[1]%%dim(lattice)[1]+1,x[2],x[3]] #after
  #x-Direction
  tmp <- tmp - 2.0*mass/zeta * point * lattice[x[1],(x[2]-2)%%dim(lattice)[2]+1,x[3]]
  tmp <- tmp - 2.0*mass/zeta * point * lattice[x[1],x[2]%%dim(lattice)[2]+1,x[3]]
  #y-Direction
  tmp <- tmp - 2.0*mass/zeta * point * lattice[x[1],x[2],(x[3]-2)%%dim(lattice)[3]+1]
  tmp <- tmp - 2.0*mass/zeta * point * lattice[x[1],x[2],x[3]%%dim(lattice)[3]+1]
  
  #Non-interacting
  tmp <- tmp + (1-2*field) * point^2 + field * point^4
  
  return(tmp)
}


field_sweep <- function(lattice, mass, field, zeta){
  #Sequentially updates the lattice.
  
  proposal <- lattice
  N <- dim(lattice)[1]
  AR <- 0 #acceptance ratio
  w <- 1 #width of uniform distr.
  
  
  for(t in seq(1,N)){
    for(x in seq(1,N)){
      for(y in seq(1,N)){
        proposal[t,x,y] <- proposal[t,x,y] + runif(n=1, min=-w, max=w)
        
        S_before <- sp_contribution(lattice, c(t,x,y), mass, field, zeta)
        #S_before <- lat_action(lattice, mass, field, zeta)
        S_after <- sp_contribution(proposal, c(t,x,y), mass, field, zeta)
        #S_after <- lat_action(proposal, mass, field, zeta)
        del_S <- S_after - S_before
        
        #Accept-Reject-Step
        if(runif(1) < exp(-del_S)){
          lattice[t,x,y] <- proposal[t,x,y]
          AR <- AR + 1
        }
        else
          proposal[t,x,y] <- lattice[t,x,y]
      }
    }
  }
  return(list("lattice"=lattice, "AR"=AR/N^3))
}


two_point <- function(lattice, mass, field, zeta, d_t){
  #Calculates the two-point-function for a given delta t on a given lattice instance.
  
  tmp <- 0
  N <- dim(lattice)[1]
  
  for(t_0 in seq(1,N)){
    for(x in seq(1,N)){
      for(y in seq(1,N)){
        tmp <- tmp + lattice[t_0,x,y] * lattice[(t_0-1+d_t)%%N+1,x,y]
      }
    }
  }
  return(tmp / N^3)
}


eff_mass <- function(corr){
  #Calculates the effective mass for all time steps.
  
  N <- length(corr)
  return(log(corr[1:N-1]/tail(corr,N-1)))
}
```


##Set up a space-time lattice
```{r}
mass <- 1e5
field <- 0
zeta <- 1

n_p <- 32 #points per dimension

#lattice <- array(data=runif(n=n_p^3, min=-1, max=1),dim=rep(n_p,3))
```


##Perform N sweeps of the lattice
```{r}
#lattice <- array(data=runif(n=n_p^3,min=-1,max=1),dim=rep(n_p,3))
#lattice <- lattice/sum(lattice)
#saveRDS(lattice, file="./size_32/rndm_init.rds")
#heatmap(x=lattice[1,,], Rowv=NA, Colv=NA, scale="none")
lattice <- readRDS("./size_32/step_20.rds")

AR <- 0 #acceptance ratio
N <- 20 #number of sweeps
for(i in seq(1,N)){
  sweep <- field_sweep(lattice, mass, field, zeta)
  lattice <- sweep$lattice
  AR <- AR + sweep$AR
  saveRDS(lattice, file=paste(c("./size_32/step_", 20+i, ".rds"), collapse = ""))
}
AR <- AR/N

#print(lattice[,,])
#heatmap(x=lattice[1,,], Rowv=NA, Colv=NA, scale="none")
```


##Evolution of simulation steps
```{r}
for(i in seq(1,10,2)){
  heatmap(x=readRDS(paste(c("./size_32/step_", i, ".rds"), collapse = ""))[5,,], Rowv=NA, Colv=NA, scale="none")
}
```

##Calculate correlator and effective masses
```{r}
lattice <- readRDS("./size_32/step_30.rds")
corr <- as.vector(unlist(lapply(X=seq(0,n_p/2), FUN="two_point", lattice=lattice, mass=mass, field=field, zeta=zeta)))
print(corr)
print("Effektive Massen:")
print(eff_mass(corr))
```



# Tests
```{r}
tmp <- array(data=seq(1,27),dim=c(3,3,3))
 
roll <- function(x, d=1, n=1){
  if(n == 0)
    return(x)
  
  N <- array(dim(x)[1])
  rolled_arr <- array(dim=dim(x))
  if(n < 0){
    n <- abs(n)
    if(d==1){
      rolled_arr[seq(1,N-n),,] <- x[seq(n+1,N),,]
      rolled_arr[seq(N-n+1,N),,] <- x[seq(1,n),,]
    }
    else if(d==2){
      rolled_arr[,seq(1,N-n),] <- x[,seq(n+1,N),]
      rolled_arr[,seq(N-n+1,N),] <- x[,seq(1,n),]
    }
    else{
      rolled_arr[seq(1,N-n),,] <- x[seq(n+1,N),,]
      rolled_arr[seq(N-n+1,N),,] <- x[seq(1,n),,]
    }
  }
  else{
    if(d==1){
      rolled_arr[seq(1+n,N),,] <- x[seq(1,N-n),,]
      rolled_arr[seq(1,n),,] <- x[seq(N-n+1,N),,]
    }
    else if(d==2){
      rolled_arr[,seq(1+n,N),] <- x[,seq(1,N-n),]
      rolled_arr[,seq(1,n),] <- x[,seq(N-n+1,N),]
    }
    else{
      rolled_arr[,,seq(1+n,N)] <- x[,,seq(1,N-n)]
      rolled_arr[,,seq(1,n)] <- x[,,seq(N-n+1,N)]
    }
  }
  
  return(rolled_arr)
}
#seq(1,2)
#seq(5)
#bla <- dim(tmp)[1]
print(tmp)
#print(roll(tmp,d=2,n=-1))
#print(tail(tmp,2))

lat_action <- function(lattice, mass, field, zeta){
  #Interacting
  #Time
  action <- -2*mass*zeta * sum(lattice * roll(lattice, d=1, n=1))
  #x-Direction
  action <- action - 2*mass/zeta * sum(lattice * roll(lattice, d=2, n=1))
  #y-Direction
  action <- action - 2*mass/zeta * sum(lattice * roll(lattice, d=3, n=1))
  
  #Non-interacting
  action <- action + (1-2*field) * sum(lattice^2) + field * sum(lattice^4)
  
  return(action)
}

print(lat_action(tmp, mass, field, zeta))
```