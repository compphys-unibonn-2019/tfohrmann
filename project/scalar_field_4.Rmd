---
title: "scalar_field"
author: "Till Fohrmann"
date: "3/6/2020"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


##Function definitions
```{r}
sp_contribution <- function(lattice, x, mass, field, zeta){
  #Calculates the parts of the action that change if the field value at on point changes.
  
  point <- lattice[x[1],x[2],x[3],x[4]]
  tmp <- 0
  
  #Interacting
  #Time
  tmp <- tmp - 2.0*mass*zeta * point * lattice[(x[1]-2)%%dim(lattice)[1]+1,x[2],x[3],x[4]] #before
  tmp <- tmp - 2.0*mass*zeta * point * lattice[x[1]%%dim(lattice)[1]+1,x[2],x[3],x[4]] #after
  #x-Direction
  tmp <- tmp - 2.0*mass/zeta * point * lattice[x[1],(x[2]-2)%%dim(lattice)[2]+1,x[3],x[4]]
  tmp <- tmp - 2.0*mass/zeta * point * lattice[x[1],x[2]%%dim(lattice)[2]+1,x[3],x[4]]
  #y-Direction
  tmp <- tmp - 2.0*mass/zeta * point * lattice[x[1],x[2],(x[3]-2)%%dim(lattice)[3]+1,x[4]]
  tmp <- tmp - 2.0*mass/zeta * point * lattice[x[1],x[2],x[3]%%dim(lattice)[3]+1,x[4]]
  #z-Direction
  tmp <- tmp - 2.0*mass/zeta * point * lattice[x[1],x[2],x[3],(x[4]-2)%%dim(lattice)[4]+1]
  tmp <- tmp - 2.0*mass/zeta * point * lattice[x[1],x[2],x[3],x[4]%%dim(lattice)[4]+1]
  
  #Non-interacting
  tmp <- tmp + (1-2*field) * point^2 + field * point^4
  
  return(tmp)
}


field_sweep <- function(lattice, mass, field, zeta){
  #Sequentially updates the lattice.
  
  proposal <- lattice
  n_t <- dim(lattice)[1]
  n_s <- dim(lattice)[2]
  AR <- 0 #acceptance ratio
  w <- 1 #width of uniform distr.
  
  
  for(t in seq(1,n_t)){
    for(x in seq(1,n_s)){
      for(y in seq(1,n_s)){
        for(z in seq(1,n_s)){
          proposal[t,x,y,z] <- proposal[t,x,y,z] + runif(n=1, min=-w, max=w)
        
          S_before <- sp_contribution(lattice, c(t,x,y,z), mass, field, zeta)
          #S_before <- lat_action(lattice, mass, field, zeta)
          S_after <- sp_contribution(proposal, c(t,x,y,z), mass, field, zeta)
          #S_after <- lat_action(proposal, mass, field, zeta)
          del_S <- S_after - S_before
        
          #Accept-Reject-Step
          if(runif(1) < exp(-del_S)){
            lattice[t,x,y,z] <- proposal[t,x,y,z]
            AR <- AR + 1
          }
          else
            proposal[t,x,y,z] <- lattice[t,x,y,z]
        }
      }
    }
  }
  return(list("lattice"=lattice, "AR"=AR/(n_t*n_s^3)))
}


two_point <- function(lattice, mass, field, zeta, d_t){
  #Calculates the two-point-function for a given delta t on a given lattice instance.
  
  n_t <- dim(lattice)[1]
  n_s <- dim(lattice)[2]
  corr <- rep(0, n_t)
  
  for(dt in seq(0,n_t-1)){
    for(t_0 in seq(1,n_t)){
      for(x in seq(1,n_s)){
        for(y in seq(1,n_s)){
          for(z in seq(1,n_s)){
            corr[dt+1] <- corr[dt+1] + lattice[t_0,x,y,z] * lattice[(t_0-1+d_t)%%n_t+1,x,y,z]
          }
        }
      }
    }
  }
  
  #Symmetrize correlator:
  corr_sym <- (head(corr, n_t/2)+tail(corr, n_t/2))/2.
  
  return(corr_sym/n_t*n_s^3)
}


eff_mass <- function(corr){
  #Calculates the effective mass for all time steps.
  
  N <- length(corr)
  return(log(corr[1:N-1]/tail(corr,N-1)))
}
```


##Set up a space-time lattice
```{r}
mass <- 1
field <- 0
zeta <- 1

n_s <- 16 #points per space dimension
n_t <- 32 #points per time dimension

#lattice <- array(data=runif(n=n_t*n_s^3,min=-1,max=1),dim=c(n_t,n_s,n_s,n_s))
#lattice <- lattice/sum(lattice)
```


##Perform N sweeps of the lattice
```{r}
lattice <- array(data=runif(n=n_t*n_s^3,min=-1,max=1),dim=c(n_t,n_s,n_s,n_s))
lattice <- lattice/sum(lattice)
#saveRDS(lattice, file="./size_32/rndm_init.rds")
#heatmap(x=lattice[1,,,], Rowv=NA, Colv=NA, scale="none")
#lattice <- readRDS("./size_32/step_20.rds")

AR <- 0 #acceptance ratio
n_sweeps <- 5 #number of sweeps
for(i in seq(1,n_sweeps)){
  sweep <- field_sweep(lattice, mass, field, zeta)
  lattice <- sweep$lattice
  AR <- AR + sweep$AR
  saveRDS(lattice, file=paste(c("./m1f0z1/step_", i, ".rds"), collapse = ""))
}
AR <- AR/n_sweeps

#print(lattice[,,])
#heatmap(x=lattice[1,,], Rowv=NA, Colv=NA, scale="none")
```


##Evolution of simulation steps
```{r}
for(i in seq(1,5,1)){
  heatmap(x=readRDS(paste(c("./m1f0z1/step_", i, ".rds"), collapse = ""))[1,1,,], Rowv=NA, Colv=NA, scale="none")
}
```

##Calculate correlator and effective masses
```{r}
lattice <- readRDS(paste(c("./m1f0z1/step_", i, ".rds"), collapse = ""))
two_point(lattice=lattice, mass=mass, field=field, zeta=zeta, d_t=0)
```


```{r}
for(i in seq(1,5)){
  lattice <- readRDS(paste(c("./m1f0z1/step_", i, ".rds"), collapse = ""))
  corr <- array(NA, dim=c(n_t,5))
  for(i in seq(1,n_t)){
    corr[,i] <- two_point(lattice=lattice, mass=mass, field=field, zeta=zeta, d_t=i)
  }
  corr_avg <- apply(X=corr, MARGIN=1, FUN=mean)
}
print(eff_mass(corr_avg))
```



# Tests
```{r}
tmp <- array(data=seq(1,27),dim=c(3,3,3))
 
roll <- function(x, d=1, n=1){
  if(n == 0)
    return(x)
  
  n_t <- dim(x)[1]
  n_s <- dim(x)[2]
  rolled_arr <- array(dim=dim(x))
  
  if(n < 0){
    n <- abs(n)
    if(d==1){
      rolled_arr[seq(1,n_t-n),,,] <- x[seq(n+1,n_t),,,]
      rolled_arr[seq(n_t-n+1,n_t),,,] <- x[seq(1,n),,,]
    }
    else if(d==2){
      rolled_arr[,seq(1,n_s-n),,] <- x[,seq(n+1,n_s),,]
      rolled_arr[,seq(n_s-n+1,n_s),,] <- x[,seq(1,n),,]
    }
    else if(d==3){
      rolled_arr[,,seq(1,n_s-n),] <- x[,,seq(n+1,n_s),]
      rolled_arr[,,seq(n_s-n+1,n_s),] <- x[,,seq(1,n),]
    }
    else{
      rolled_arr[,,,seq(1,n_s-n)] <- x[,,,seq(n+1,n_s)]
      rolled_arr[,,,seq(n_s-n+1,n_s)] <- x[,,,seq(1,n)]
    }
  }
  else{
    if(d==1){
      rolled_arr[seq(1+n,n_t),,,] <- x[seq(1,n_t-n),,,]
      rolled_arr[seq(1,n),,,] <- x[seq(N-n+1,n_t),,,]
    }
    else if(d==2){
      rolled_arr[,seq(1+n,n_s),,] <- x[,seq(1,n_s-n),,]
      rolled_arr[,seq(1,n),,] <- x[,seq(n_s-n+1,n_s),,]
    }
    else if(d==4){
      rolled_arr[,,seq(1+n,n_s),] <- x[,,seq(1,n_s-n),]
      rolled_arr[,,seq(1,n),] <- x[,,seq(n_s-n+1,n_s),]
    }
    else{
      rolled_arr[,,,seq(1+n,n_s)] <- x[,,,seq(1,n_s-n)]
      rolled_arr[,,,seq(1,n)] <- x[,,,seq(n_s-n+1,n_s)]
    }
  }
  
  return(rolled_arr)
}
#seq(1,2)
#seq(5)
#bla <- dim(tmp)[1]
print(tmp)
#print(roll(tmp,d=2,n=-1))
#print(tail(tmp,2))

lat_action <- function(lattice, mass, field, zeta){
  #Interacting
  #Time
  action <- -2*mass*zeta * sum(lattice * roll(lattice, d=1, n=1))
  #x-Direction
  action <- action - 2*mass/zeta * sum(lattice * roll(lattice, d=2, n=1))
  #y-Direction
  action <- action - 2*mass/zeta * sum(lattice * roll(lattice, d=3, n=1))
  #z-Direction
  action <- action - 2*mass/zeta * sum(lattice * roll(lattice, d=4, n=1))
  
  #Non-interacting
  action <- action + (1-2*field) * sum(lattice^2) + field * sum(lattice^4)
  
  return(action)
}

print(lat_action(tmp, mass, field, zeta))
```