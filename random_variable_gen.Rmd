---
title: "3. Random variable generation"
author: "Till Fohrmann"
date: "10/30/2019"
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

The goal is to sample $X \sim f_X$ with $f_X(x) = \frac{1}{\pi} \, \frac{1}{\sqrt{x(1-x)}}$.

## 1b
```{r, fig.align="center"}
# Function to sample from
f <- function(x){
  return(2/pi*asin(sqrt(x)))
}

# Inverse
f_inv <- function(y){
  return(sin(pi/2 * y)^2)
}

# Plot Inv(F(x)) against x
x <- seq(from=0.01, to=0.99, by=0.005)
y <- f_inv(f(x))
plot(x=x, y=y, xlab="x", ylab=expression(paste("F"^"-1","(F(x))")), pch=".")
```

Since $F^{-1}(F(x))$ plotted against $x$ produces a line, the derivation of the inverse seems to be correct.

## 1c
```{r, fig.align="center"}
# Use the inverse to sample n points from f(x)
n <- 1e4
y <- runif(n, min=0.01, max=0.99)
fx_gen <- f_inv(y)

# Values of the target distribution
x <- seq(0.01, 0.99, 0.01)
fx <- 1/(pi*sqrt(x*(1-x)))


hist(fx_gen, probability=TRUE, xlab="x", ylab="Density / f(x)",
     main="Histogram of sample vs. original distribution")
lines(x,fx, col="red")
```

Visually speaking the sample generated by the *generalized inverse transform method* matches the target distribution.

## 2
```{r}
# Implementation of a linear congruential random number generator
rand <- function(a,m, n, seed=1){
  tmp <- rep(seed, times=n)
  for(i in 2:n){
    tmp[i] <- (a * tmp[i-1]) %% m
  }
  return(tmp)
}

# Generate random numbers
results <- array(dim=c(3,1e4))

results[1,] <- rand(7^5,2^(31)-1, 1e4)
results[2,] <- rand(19, 6788793, 1e4)
results[3,] <- rand(65539, 2^(31), 1e4)

# Calculate mean values and variances
means <- apply(results, 1, mean)
vars <- apply(results, 1, var)

for(i in 1:3){
  print(paste("Mean value: ", means[i], "  Variance: ", vars[i]))
}
```

```{r}
library(scatterplot3d)
ind <- c(1:9998)
set1 <- results[1,]/(2^(31)-1)
set2 <- results[2,]/(6788793)
set3 <- results[3,]/(2^(31))
scatterplot3d(x=set3[ind],y=set3[ind+1],z=set3[ind+2], angle=40 , xlab=expression("x"[i]),
              ylab=expression("x"[i+1]), zlab=expression("x"[i+2]))
```